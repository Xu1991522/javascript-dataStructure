<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>binaTree</title>
</head>
<body>
    
    <script type="text/javascript">
      function BinaryTree() { // 构造二叉树对象方法
        var Node = function(key) { // 节点对象
            this.key = key; // 当前节点值
            this.left = null; // 当前节点的左子节点
            this.right = null; //当前节点的右子节点
        }

        var root = null; // 根节点

        var insertNode = function(node, newNode) { // 把节点插入的具体实现方法
            // 逻辑： 判断新节点值是否小于当前节点（即父节点）值：1.小于时，再判断当前节点的左节点是否为空，当为空时，把新节点值赋给当前节点的左子节点，当当前节点的子左节点不为空时，再把新节点值与当前节点的左子节点比较循环处理下去。 2.新节点值大于当前节点值时，除了为右节点其他逻辑一样。
            if(newNode.key < node.key){
                if(node.left === null) {
                    node.left = newNode;
                } else {
                    insertNode(node.left, newNode);
                }
            } else {
                if(node.right === null) {
                    node.right = newNode;
                } else {
                    insertNode(node.right, newNode);
                }
            }
        }

        this.insert = function(key) { // 插入节点：父与子节点之间的关系，相当于二叉图中的箭头
            var newNode = new Node(key); // 实例化一个节点
            if (root === null) {  // 当根节点为空时，把插入的节点赋给父节点
                root = newNode // 插入的节点赋给父节点
            } else { //当父节点不为空时，调用插入方法：根据左节点值小于父节点值，右节点值大于父节点值规律插入
                insertNode(root, newNode)
            }
        }
      }

      var nodes = [8, 3, 18, 1, 6, 14, 4, 7, 13]
        var binaryTree = new BinaryTree();
        console.log(nodes)
        console.log(binaryTree)
        debugger
        nodes.forEach(function(key) {
            binaryTree.insert(key)
        })
         console.log(nodes)
    </script>
</body>
</html>